Антипатерны Backbone
====================

Создатели Backbone.js потратили много времени и сил для популяризации MVC среди javascript разработчиков. Однако, многие новички в Backbone (в том числе и автор перевода(смайл) ) все равно задаются вопросом, как же  поступать «правильно» в той или иной ситуации. 

И тут есть 2-е новости - хорошая и плохая. Плохая заключается в том, что «верного пути» просто не существует. Все зависит от конкретной задачи, которую требуется решить. Хорошая новость - что сложился ряд «плохих практик» или антипаттренов, которые не стоит допускать в своем коде. 

В этой статье я попытаюсь рассказать о некоторых антипаттернах. Забегая вперед, скажу, что не стоит расстраиваться, если вы заметили какой-нибудь антипаттерн у себя в коде. Все мы люди и нам свойственно делать ошибки.

Антипаттерн 1 Создание одностаничных (single page) приложение, когда этого не требуется
---------------------------------------------------------------------------------------

Данный антипаттерн относится не столько к Backbone, сколько к архитектуре самого приложения.

На первый взгляд, концепция одностраничного приложения выглядит весьма заманчиво. Не нужно собирать кусочки вашего приложения на стороне сервера. Достаточно всего лишь определить JSON API, а дальше всю работу делать «на клиенте». Однако здесь есть ряд подводных камней, о которых следует позаботиться. (Так поступают в приложениях для Smart-TV – прим. переводчика).

Во-первых, это базы данных. Если на бекэнде (backend) вы используете какую-либо базу данных (а это скорее всего так), то JSON API становится всего лишь еще одной прослойкой между пользовательским интерфейсом и этой базой данных. С точки зрения разработки, намного проще и удобнее держать код, отвечающий за взаимодействие с пользователем, на сервере и напрямую общаться с базой данных при помощи SQL-запросов, чем реализовывать это взаимодействие при помощи JSON API.

Во-вторых, сама по себе разработка одностраничного приложения - довольно трудная задача, тем более, если раньше вы использовали PHP или Rails, которые работают синхронно, по принципу «запрос-ответ».

Одностраничные приложения основаны на принципах СОП. Это означает, что они - асинхронны, а объекты в таких приложениях могут существовать долгое время.
И в конце концов, кто вам сказал, что используя Backbone (или другой framework, например, тот же Angular) вы обязаны писать полностью одностраничное приложение? Можно попытаться использовать эти framework’и для каких-то UX-частей вашей программы. Например, парни из 37Signals использовали Backbone в своем новом приложении Basecamp calendar, но вовсе не делали его одностраничным.

Антипаттерн 2 Использовать Backbone, когда нужно использовать другой framework
------------------------------------------------------------------------------

Выбор MVC Framework’а для вашего проекта - один из очень важных этапов работы. И Backbone - не панацея от всех болезней! Посмотрите мой пост Backbone Is Not Enough, чтобы понять почему он может не подойти для многих js приложений.

Антипаттерн 3 Никаких View-тестов
---------------------------------

Модели (model) в Backbone хорошо заточены для Unit тестов. С Представлениями (view) дела обстоят немного сложнее. Но это не означает, что их не следует тестировать!
В дополнение к хорошо известным преимуществам, которые дает Unit тестирование (улучшение качества кода и тд), написание тестов для Представлений заставляет вас задуматься о структуре вашего кода. Поскольку обеспечить взаимодействие Представлений через глобальные переменные и недокументированные свойства очень просто, код, не покрытый тестами, стремится к состоянию, в котором нет четко выделенных фрагментов. А это очень плохо.

О тестировании Представлений в Backbone можно почитать мой предыдущий пост Testing Backbone Views with QUnit and Sinon.

Антипаттерн 4 Никакой заботы о памяти
-------------------------------------

Отстутсвие контроля за памятью уже стало классической ошибкой. В результате утечки памяти, приложение может сломаться в самый неподходящий момент.
«Как же такое может быть?» - спросите вы. «Ведь мой код очень сжат и должен быть утилизирован при помощи Garbage collector». К сожалению, все-таки есть один источник утечки памяти, с которым javascript не может справиться сам. Это - Представления. Именно они продолжают прослушивать Модели, даже когда сами больше не отображаются. Представления же остаются в памяти потому, что Модели все еще хранят ссылки на них. И такая куча «зомби Представлений» все время пополняется.

К нашему счастью, эта проблема хорошо известна и имеет несколько решений. Во-первых, следует использовать метод Backbone «ListenTo» при подписке на события, вместо «on/bind» методов. Таким образом, тот, кто подписывается на событие, может сохранить список прослушиваемых им объектов. Во-вторых, вам (ну или вашему менеджеру Представлений – мы юзаем Backbone LayoutManager) следует явно отдавать приказ Представлениям о прекращении прослушивания событий, которые больше не используются.

Антипаттерн 5 Data Attributes в DOM
-----------------------------------

Следующий антипаттерн, пожалуй, самый распространенный среди новичков. Скорее всего, он перекочевал к нам из jQuery. Рассмотрим его на примере.
Допустим, мы хотим вывести список людей. Предположим, что при клике на какой-либо пункт списка срабатывае событие ‘onclick’.

Теперь давайте взглянем на проблемную часть кода. Вначале Шаблон (допустим, что мы используем Undersoce):

```
<script id="people" type="text/template">
  Here is our list of people:
  <ul>
    <% people.each(function(person) { %>
      <li class='person' data-id='<%= person.id %>'>
        Hi, my name is <%= person.get('name') %>
      </li>
    <% }); %>
  </ul>
</script>
```

Чувствуете подвох? Теперь - Представление:

```
var PeopleView = Backbone.View.extend({
  events: {
    'click .person': '_personClicked'
  },
  render: function() {
    var renderTemplate = _.template($('#people').text());
    this.$el.html(renderTemplate({people: this.collection}));
  },
  _personClicked: function(e) {
    var personId = $(e.currentTarget).data('id');
    var person = this.collection.get(personId);
    $(e.currentTarget).text(
      'Nice to meet you, ' + person.get('name')
    );
  }
});
```

Что тут не так? - Дело в том, что вставка data-атрибута в DOM, а затем его повторный вызов противоречат самой сути Backbone. По мере усложнения Пользовательского Интерфейса(UI) это может привести к проблемам.

Давайте лучше воспользуемся возможностями, которые предлагает Backbone для связывания кусочков DOM с данными. Можно заметить, что между каждой Моделью Person и элементом <li> DOM дерева существует связь один-к-одному. Ее можно использовать, создав Представление, которое станет связующим звеном между ними:

Вначале изменим Шаблон для вывода списка людей:

```
<script id="people" type="text/template">
    Here is our list of people:
    <ul></ul>
</script>
```
и создадим еще один Шаблон для одного человека:

```
<script id="person" type="text/template">
  Hi, my name is <%= person.get('name') %>
</script>
```

Далее напишем Представление для Модели Person:

```
var PersonView = Backbone.View.extend({
  tagName: 'li',
  events: {
    'click': '_clicked'
  },
  render: function() {
    var renderTemplate = _.template($('#person').text());
    this.$el.html(renderTemplate({person: this.model}));
    return this;
  },
  _clicked: function() {
    this.$el.text(
      'Nice to meet you, ' + this.model.get('name')
    );
  }
});
```

И наконец, исправим PeooleView (представление для списка людей):

```
var PeopleView = Backbone.View.extend({
  render: function() {
    var renderTemplate = _.template($('#people').text());
    this.$el.html(renderTemplate({people: this.collection}));
 
    this.collection.each(function(person) {
      this.$('ul').append(
        new PersonView({model: person}).render().$el
      );
    }, this);
  }
});
```

Заметьте, что мы не использовали data-атрибуты и обработчики событий. Такой подход упрощает тестирование, потому теперь можно написать отдельные тесты для Представления PersonView.

Не нужно стесняться того, что у вас в приложении много Представлений. Скажу по секрету, я сам довольно редко использую итераторы в шаблонах. Только если вывожу данные чисто для чтения (read-only).

Мне кажется, что использовать data-атрибуты в коде - намного накладнее и может привести к проблемам в будущем.

Антипаттерн 6 Асинхронный рендеринг шаблонов 
--------------------------------------------

Framework’и такие как Backbone.LayoutManager позволяют легко загружать Шаблоны асинхронно. Однако, многие не до конца осознают насколько асинхронность усложняет код и его тестирование. Ее стоит использовать в случае крайней необходимости. Довольно часто асинхронная загрузка Шаблонов просто не нужна.
Маловероятно, что на Продакшне (production environments) вы будете загружать каждый Шаблоны отдельно по сети. Скорее всего, они будут предзагружены и встроены в ваше приложение. А значит, что они никогда не будут загружаться асинхронно.

В таком случае асинхронная загрузка шаблонов может пригодиться вам только при разработке приложения локально (local development environment). Но как ни странно, если переключиться на синхронную загрузку на локольной машине вы не заметите ощутимой разницы, потому что все запросы также будут локальными.
Поэтому нет никакого смысла загружать шаблоны асинхронно. Так зачем же это делать вообще? Во многих своих проектах, на деве(dev) я юзал опцию ‘async:false’ в Ajax запросах, которые извлекали Шаблоны. Мой код становился проще, а работал не намного медленнее.

Если же вам не нравится превращать свой код в одну большую простыню (кода), то можно разбить его на чанки (chunks) и загружать их по отдельности. Однако, каждый чанк должен включать как свой код, так и скомпилированный Шаблон, относящийся к части вашего приложения. Загрузка Шаблонов по мере их необходимости может привести к сильной фрагментации кода. Такое приложение получится очень некрасивым и сложным.

Антипаттерн 7 Недокументированные Опции (Options)
-------------------------------------------------

Модели в Backbone можно создавать вместе с объектом ‘options’, который может содержать любые данные. Поэтому эти объекты так удобны: с их помощью можно передать любую информацию в Представления. Однако не стоит ими злоупотреблять - нельзя объявлять их где попало (например, в качестве аргумента метода initialize()).

В ранних версиях Backbone этот объект автоматически связывался с this.options. В версии Backbone 1.1, ситуация немного улучшилась и подобная (автоматическая) привязка больше не происходит. Однако это можно сделать вручную.
Представьте, что вы впервые видите чужой код. Придется изрядно попотеть, прежде чем вы догадаетесь об ‘options’, особенно если они запрятаны глубоко в классе:

```
  var MyView = Backbone.View.extend({
  initialize: function(options) {
    this._options = options;
  },
  // … lots more code
  doStuff: function() {
    // ... do a bunch of stuff
      this._options.obscureBackdoor.doSomethingCrucial();
    // … do a bunch more stuff
  }
  // ... do more stuff
});
```

Никто даже не догадается, что в Представлении есть такая дырка (obscure backdoor) до тех пор, пока не обнаружит сслыку на объект ‘options’ в коде.
Это довольно неприятно, потому что каждый объект ’option’ в Представлении фактически является связью Представления с этим объектом. Другими словами, опции, получаемые Представлением, становятся частью его публичного интерфейса.

Таким образом, я настоятельно рекомендую, документировать все опции Моделей и Представлений как-то так:

```
/**
 * options: 
 * - obscureBackdoor: a now slightly-less obscure backdoor
 */
var MyView = Backbone.View.extend({
  ...
});
```

Если уж вы очень дотошный человек, то можете прописать какие какие опции являются обязательными, а какие - нет. Или вы можете даже проверять обязательные опции в методе initialize() ваших объектов. Помните, что недокументированный код превращается в непонятный спагетти код с кучей дырок!

Антипаттерн 8 Использование Пользовательских событий (Custom Events) без необходимости
--------------------------------------------------------------------------------------

Новички в Backbone просто тащатся от того, что практически все может генерировать события. Следовательно, они начинают придумывать свои собственные события.
Но тут есть несколько проблем.

Во-первых, события, генерируемые, объектами становятся частью их (объектов) публичного интерфейса. Таким образом, если вы хотите создавать свои собственные события, не забывайте их документировать. В противном случае вы оставляете в своем коде дырки, которые потом трудно обнаружить.

Во-вторых, часто пользовательские события добавляют в код под предлогом его «разделения». Но на деле, если требуемое поведение достигается (имплементируется) при помощи двух объектов, взаимодействующих благодаря пользовательскому событию - в этом случае объекты все равно остаются связанными. Просто на другом уровне абстракции.
Если говорить о Представлениях, то у меня ни разу не было проблем с тем, что два Представления как-то связаны друг с другом. Только не забывайте документировать эту связь (см антипаттерн 7). Такая штука просто и легко тестируется.

«Хорошее событие» отвечает нескольким критериям: оно хорошо определено, понятно и может быть использовано более чем в одном случае. Встроенные события Backbone (http://backbonejs.org/#Events-catalog) отвечают всем этим требованиям. Они сослужат вам хорошую службу, когда вы разберетесь как они работают.

Например, один из способов использовать события Backbone по максимому – наладить взаимодействие между нескольким Представлениями через лежащие в их основе Модели, которые используются в этих Представлениях. Какое-то Представление может инициировать изменение Модели, которая в свою очередь обновит другую Модель. Это изменение будет подхвачено другим Представлением, которое «прослушивает» событие ‘onChange’. 

Использование индивидуальных Представлений-Моделей (view-models) в сложных Представлениях может быть весьма удобным. К тому же они легко тестируются. Заметьте, что нам не потребовалось использование пользовательских событий. 

Мне кажется уместным использовать пользовательские события для компонентов интерфейса, таких как табы (tabs) или аккордеоны(accordions). Благодаря Пользовательским Событиям можно оперделить что чем занимается тот или иной компонент, а затем - преобразовать (кастомизировать) его под свои нужды. Только не забывайте документировать свои Пользовательские События. 

Антипаттерн 9 Написание реляционных отображений (Relationship Mapper)
---------------------------------------------------------------------

(Чтобы понять о чем идет речь в этом антипаттерне, я бы рекомендовал прочитать статью об ORM - прим. переводчика)

В сложных приложениях часто приходится преобразовывать (десериализовывать) данные, полученные от сервера, в дерево Моделей и Коллекций Backbone. А затем еще раз сериализовать это дерово (или части этого дерева) уже для отображения в Шаблонах или для отправки обратно на сервер. 

Один из способов решения этой проблемы - вручную переписать методы ‘parse’ и ‘toJSON’ в ваших Моделях. Однако, когда дальше вам понадобиться отложенно загрузить(lazy load) определенные части вашего дерева, придется позаботиться о какой-то специфической логике. Вскоре вам надоест повторяющийся код в методах ‘parse’ и ‘toJSON’ и вы попробуете написать логику, которая бы декларативно формулировала ваши зависимости. Потом вы обнаружите что объект с одинаковыми ID и типом появляется в разных частях вашего JSON. Тогда вам захочется представить его тоже в виде Модели. Таким образом вам понадобится реализовать что-то вроде карт соответсвия (identity map).

(Я думаю, что в предпоследнем предложении речь идет об обеспечении однократной загрузки объекта(см identity map) – прим. переводчика)

Очень быстро вы поймете, что пытаетесь написать что-то типа реляционного отображения (relational mapper). А этого без особой нужды делать не следует.

Объектно-реляционное отображение только на первый взгдял что-то простое и обыденное, но на самом деле там полно оно изобилует «тонкими моментами».

Слава богу, что существует несколько Backbone framework’ов, которые делают такие штуки за вас. Пожалуй, главный из них - это Backbone-Relational. Backbone-Relational - очень мощный framework, включающий в себя карты присутствия(identity map). Но, как и в любом другом O/R mapper’е, вы можете легко прострелить себе ногу, если не удосужитесь разобраться во всех тонкостях работы. Backbone-Associations и Backbone-Nested намного проще и их вполне может быть достаточно для решения ваших задач.

Прежде чем реализовывать что-то самому, убедитесь, что никто не сделал это до вас.

Антипаттерн 10 Лишние div
-------------------------

Это не самый важный антипаттерн. Однако, я думаю, что его следует упомянуть, потому что некоторые даже не догадываются о его существовании.
Следует отметить, что Backbone по умолчанию создает пустые элементы для каждого Представления во время рендеринга Шаблона.

Это может привести к появлению огромного числа пустых <div> в вашем выходном HTML.
Взгляните на код ниже:

```
<script type="text/template" id="section">
  <section class='myClass'>
    This is a section
  </section>
</script>
```

Представление будет выглядеть так:

```
var View = Backbone.View.extend({
  render: function() {
    this.$el.html(_.template($('#section').text())());
  }
});
```

После рендеринга Шаблона мы получим что-то такое:

```
<div>
  <section class="myClass">
    This is a section
  </section>
</div>
```

А теперь представьте, сколько получится таких пустышек, когда ваше DOM-дерево разрастется.

Следует отметить, что Backbone позволяет настраивать корневой элемент Представления и даже указывать его тег. Зная об этом, можно переписать шаблон следующим образом:

```
<script type="text/template" id="section">
    This is a section
</script>
```
И добавить больше информации о корневом элементе в Представление:

```
var View = Backbone.View.extend({
  tagName: 'section',
  className: 'myClass',
  render: function() {
    this.$el.html(_.template($('#section').text())());
  }
});
```

После рендеринга мы получим следующий код:

```
<section class="myClass">
  This is a section
</section>
```

Намного лучше, не так ли? 

Раньше я до конца не понимал, почему говорят Представления так называются, ведь они больше похожи на контроллеры Контроллеры, но сейчас я понял это!
(по видимому, автор имеет ввиду, что в Представлениях не должно быть кода – прим переводчика)

Мне кажется, что код с пустыми элементами выглядит по меньшей мере странно. Используйте по максимому все возможности Backbone, и пусть вас не смущает, что в вашем Представлении появится какие-то штуки, связанные с отображением. Собственно поэтому на то они и Представления. 

Напутствие
----------

Итак, подведем итоги. В этом посте я рассмотрел 10 антипаттренов Backbone.js, начиная с самых фундаментальных и заканчивая довольно специфическими. Я прекрасно понимаю, что говоря о том, чего делать не надо, я оставляю еще довольно много граблей.
Поэтому, если бы мне предложили дать напутствующий совет начинающему Backbone разработчику он бы звучал так: «Пляши от UX». Те я хочу сказать, что код нужно писать с оглядкой на ваши Шаблоны и Представления, а не пытаться соблюсти все причудливые архитектурные подходы. Не нужно бояться использовать кучу Предвставлений и связывать их между собой (конечно, если это необходимо).

Не забывайте тестировать все, что вы делаете. Видите повторяющуюся логику в Представлении? - Спихните ее в Модели. Представления все еще хотят знать, когда обновляются Модели? - Начните использовать слушателей событий в Моделях таким образом, чтобы Представления заранее не знали, когда им надо обновиться. Представления стали слишком большими? - Разбейте их на отдельные куски кода. Они все еще сложны для понимания? - Так добавьте дополнительный промежуточный слой Представления-Моделей (view-models).

Постоянный цикл кодинг/тестирование/рефакторинг обычно помогает понять, что вы на верном пути. Не забываей о code-review! Постарайтесь ознакомиться со всеми возможностями, которые предлагает вам Backbone и его плагины, чтобы не понаделать велосипедов!
Если у вас есть свои Антипаттерны Backbone, с радостью взгдяну на них!